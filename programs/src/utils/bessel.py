import numpy as np
from numba import njit

MACHEP = np.finfo(float).eps

DR1 = 5.78318596294678452118
DR2 = 30.4712623436620863991
PIO4 = 0.78539816339744830962
SQ2OPI = 0.79788456080286535588
THPIO4 = 2.35619449019234492885
Z1 = 14.6819706421238932572
Z2 = 49.2184563216946036703

# Cephes polynomials for j0

RP = np.array([
    -4.79443220978201773821e9,
     1.95617491946556577543e12,
    -2.49248344360967716204e14,
     9.70862251047306323952e15,
])
RQ = np.array([
     4.99563147152651017219e2,
     1.73785401676374683123e5,
     4.84409658339962045305e7,
     1.11855537045356834862e10,
     2.11277520115489217587e12,
     3.10518229857422583814e14,
     3.18121955943204943306e16,
     1.71086294081043136091e18,
])
PP = np.array([
    7.96936729297347051624e-4,
    8.28352392107440799803e-2,
    1.23953371646414299388e0,
    5.44725003058768775090e0,
    8.74716500199817011941e0,
    5.30324038235394892183e0,
    1.0,
])
PQ = np.array([
    9.24408810558863637013e-4,
    8.56288474354474431428e-2,
    1.25352743901058953537e0,
    5.47097740330417105182e0,
    8.76190883237069594232e0,
    5.30605288235394617618e0,
    1.0,
])
QP = np.array([
   -1.13663838898469149931e-2,
   -1.28252718670509318512e0,
   -1.95539544257735972385e1,
   -9.32060152123768231369e1,
   -1.77681167980488050595e2,
   -1.47077505154951170175e2,
   -5.14105326766599330220e1,
   -6.05014350600728481186e0,
])
QQ = np.array([
     6.43178256118178023184e1,
     8.56430025976980587198e2,
     3.88240183605401609683e3,
     7.24046774195652478189e3,
     5.93072701187316984827e3,
     2.06209331660327847417e3,
     3.05605097708927854721e2,
])

# Cephes polynomials for j1

RP1 = np.array([
    -8.99971225705559398224e8,
     4.52228297998194034323e11,
    -7.27494245221818276015e13,
     3.68295732863852883286e15,
])
RQ1 = np.array([
     6.20836478118054335476e2,
     2.56987256757748830383e5,
     8.35146791431949253037e7,
     2.21511595479792499675e10,
     4.74914122079991414898e12,
     7.84369607876235854894e14,
     8.95222336184627338078e16,
     5.32278620332680085395e18,
])

PP1 = np.array([
    7.62125616208173112003e-4,
    7.31397056940917570436e-2,
    1.12719608129684925192e0,
    5.11207951146807644818e0,
    8.42404590141772420927e0,
    5.21451598682361504063e0,
    1.00000000000000000254e0,
])
PQ1 = np.array([
    5.71323128072548699714e-4,
    6.88455908754495404082e-2,
    1.10514232634061696926e0,
    5.07386386128601488557e0,
    8.39985554327604159757e0,
    5.20982848682361821619e0,
    9.99999999999999997461e-1,
])

QP1 = np.array([
    5.10862594750176621635e-2,
    4.98213872951233449420e0,
    7.58238284132545283818e1,
    3.66779609360150777800e2,
    7.10856304998926107277e2,
    5.97489612400613639965e2,
    2.11688757100572135698e2,
    2.52070205858023719784e1,
])
QQ1 = np.array([
    7.42373277035675149943e1,
    1.05644886038262816351e3,
    4.98641058337653607651e3,
    9.56231892404756170795e3,
    7.99704160447350683650e3,
    2.82619278517639096600e3,
    3.36093607810698293419e2,
])


@njit
def _polevl(x, coef, N):
    ans = coef[0]
    for i in range(1, N+1):
        ans = ans * x + coef[i]
    return ans

@njit
def _p1evl(x, coef, N):
    ans = x + coef[0]
    for i in range(1, N):
        ans = ans * x + coef[i]
    return ans

@njit
def j0(x):
    """ Returns Bessel j0 evaluated in x.
    Implementation of cephes j0.c.

    Args:
        x (float)

    Returns:
        float: j0(x)
    """
    if x < 0.0:
        x = -x
    if x <= 5.0:
        z = x * x
        if x < 1.0e-5:
            return 1.0 - z/4.0
        p = (z - DR1) * (z - DR2)
        p = p * _polevl(z, RP, 3) / _p1evl(z, RQ, 8)
        return p
    
    w = 5.0 / x
    q = 25.0 / (x*x)
    p = _polevl(q, PP, 6) / _polevl(q, PQ, 6)
    qv = _polevl(q, QP, 7) / _p1evl(q, QQ, 7)
    xn = x - PIO4
    p = p * np.cos(xn) - w * qv * np.sin(xn)
    return p * SQ2OPI / np.sqrt(x)

@njit
def j1(x):
    w = x
    if x < 0.0:
        w = -x

    if w <= 5.0:
        z = x * x
        w = _polevl(z, RP1, 3) / _p1evl(z, RQ1, 8)
        w = w * x * (z - Z1) * (z - Z2)
        return w

    w = 5.0 / x
    z = w * w
    p = _polevl(z, PP1, 6) / _polevl(z, PQ1, 6)
    q = _polevl(z, QP1, 7) / _p1evl(z, QQ1, 7)
    xn = x - THPIO4
    p = p * np.cos(xn) - w * q * np.sin(xn)
    return p * SQ2OPI / np.sqrt(x)

@njit
def jn(n, x):
    sign = 1
    if n < 0:
        n = -n
        if (n & 1) != 0:
            sign = -1

    if x < 0.0:
        if n & 1:
            sign = -sign
        x = -x

    if n == 0:
        return sign * j0(x)
    if n == 1:
        return sign * j1(x)
    if n == 2:
        return sign * (2.0 * j1(x) / x - j0(x))

    if x < MACHEP:
        return 0.0

    # --- continued fraction ---
    k = 53
    pk = 2.0 * (n + k)
    ans = pk
    xk = x * x

    for i in range(k):
        pk -= 2.0
        ans = pk - (xk / ans)
    ans = x / ans

    # --- backward recurrence ---
    pk = 1.0
    pkm1 = 1.0 / ans
    r = 2.0 * (n - 1)

    for i in range(n-1, 0, -1):
        pkm2 = (pkm1 * r - pk * x) / x
        pk = pkm1
        pkm1 = pkm2
        r -= 2.0

    if np.abs(pk) > np.abs(pkm1):
        ans = j1(x) / pk
    else:
        ans = j0(x) / pkm1

    return sign * ans

