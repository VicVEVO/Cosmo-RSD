import numpy as np
from numba import njit

DR1 = 5.78318596294678452118
DR2 = 30.4712623436620863991
PIO4 = 0.78539816339744830962
SQ2OPI = 0.79788456080286535588

RP = np.array([
    -4.79443220978201773821e9,
     1.95617491946556577543e12,
    -2.49248344360967716204e14,
     9.70862251047306323952e15,
])
RQ = np.array([
     4.99563147152651017219e2,
     1.73785401676374683123e5,
     4.84409658339962045305e7,
     1.11855537045356834862e10,
     2.11277520115489217587e12,
     3.10518229857422583814e14,
     3.18121955943204943306e16,
     1.71086294081043136091e18,
])
PP = np.array([
    7.96936729297347051624e-4,
    8.28352392107440799803e-2,
    1.23953371646414299388e0,
    5.44725003058768775090e0,
    8.74716500199817011941e0,
    5.30324038235394892183e0,
    1.0,
])
PQ = np.array([
    9.24408810558863637013e-4,
    8.56288474354474431428e-2,
    1.25352743901058953537e0,
    5.47097740330417105182e0,
    8.76190883237069594232e0,
    5.30605288235394617618e0,
    1.0,
])
QP = np.array([
   -1.13663838898469149931e-2,
   -1.28252718670509318512e0,
   -1.95539544257735972385e1,
   -9.32060152123768231369e1,
   -1.77681167980488050595e2,
   -1.47077505154951170175e2,
   -5.14105326766599330220e1,
   -6.05014350600728481186e0,
])
QQ = np.array([
     6.43178256118178023184e1,
     8.56430025976980587198e2,
     3.88240183605401609683e3,
     7.24046774195652478189e3,
     5.93072701187316984827e3,
     2.06209331660327847417e3,
     3.05605097708927854721e2,
])

@njit
def _polevl(x, coef, N):
    ans = coef[0]
    for i in range(1, N+1):
        ans = ans * x + coef[i]
    return ans

@njit
def _p1evl(x, coef, N):
    ans = x + coef[0]
    for i in range(1, N):
        ans = ans * x + coef[i]
    return ans

@njit
def j0(x):
    """ Returns Bessel j0 evaluated in x.
    Implementation of cephes j0.c.

    Args:
        x (float)

    Returns:
        float: j0(x)
    """
    if x < 0.0:
        x = -x
    if x <= 5.0:
        z = x * x
        if x < 1.0e-5:
            return 1.0 - z/4.0
        p = (z - DR1) * (z - DR2)
        p = p * _polevl(z, RP, 3) / _p1evl(z, RQ, 8)
        return p
    
    w = 5.0 / x
    q = 25.0 / (x*x)
    p = _polevl(q, PP, 6) / _polevl(q, PQ, 6)
    qv = _polevl(q, QP, 7) / _p1evl(q, QQ, 7)
    xn = x - PIO4
    p = p * np.cos(xn) - w * qv * np.sin(xn)
    return p * SQ2OPI / np.sqrt(x)